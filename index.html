<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>2D 打鴨子：儲值卡 vs 信用卡流程</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b1020; font-family: system-ui, -apple-system, "Noto Sans TC", sans-serif; }
    #wrap { height: 100%; display: grid; grid-template-rows: auto 1fr auto; }
    header {
      padding: 12px 14px; color: #fff;
      display:flex; gap:12px; flex-wrap:wrap; align-items:center;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    }
    header .pill{
      padding: 4px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      font-size: 12px; opacity: .95;
    }
    header b { font-weight: 800; }
    #game {
      position: relative;
      overflow: hidden;
      background:
        radial-gradient(1200px 600px at 50% 120%, rgba(90,120,255,0.18), transparent 60%),
        radial-gradient(900px 600px at 20% 0%, rgba(0,255,200,0.10), transparent 55%),
        radial-gradient(900px 700px at 80% 10%, rgba(90,120,255,0.10), transparent 55%),
        #0b1020;
      touch-action: manipulation;
      cursor: crosshair;
    }
    canvas { display:block; width:100%; height:100%; }
    footer{
      padding: 10px 14px; color:#cfd6ff; font-size: 13px;
      border-top: 1px solid rgba(255,255,255,0.12);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background: rgba(0,0,0,0.25);
    }
    button{
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:#fff; padding: 8px 12px; border-radius: 10px;
      cursor:pointer;
    }
    button:hover{ background: rgba(255,255,255,0.10); }
    .hint { opacity:.95 }
    .kbd{ padding: 2px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.18); font-size:12px; }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <div class="pill"><b id="qTitle">題目</b>：<span id="qText"></span></div>
      <div class="pill">分數：<b id="score">0</b></div>
      <div class="pill">連對：<b id="streak">0</b></div>
      <div class="pill">回合：<b id="round">1</b> / <b id="roundMax">5</b></div>
      <div class="pill">提示：點擊/觸控鴨子即可射擊</div>
    </header>

    <div id="game">
      <canvas id="c"></canvas>
    </div>

    <footer>
      <div class="hint" id="msg">按「開始」出第一波鴨子。</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <span class="kbd">手機：直接點</span>
        <span class="kbd">電腦：滑鼠點</span>
        <button id="startBtn">開始</button>
        <button id="restartBtn">重來</button>
      </div>
    </footer>
  </div>

<script>
(() => {
  // ====== Canvas setup ======
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const gameEl = document.getElementById('game');

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(gameEl.clientWidth * dpr);
    canvas.height = Math.floor(gameEl.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);

  // ====== UI refs ======
  const qText = document.getElementById('qText');
  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const roundEl = document.getElementById('round');
  const roundMaxEl = document.getElementById('roundMax');
  const msgEl = document.getElementById('msg');

  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');

  // ====== Content ======
  const CHOICES = [
    { key: 'prepaid', label: '儲值卡', flow: '先儲值 → 再消費', desc: '你先把錢存進卡，再扣卡內餘額' },
    { key: 'credit',  label: '信用卡', flow: '先消費 → 後繳款', desc: '你先拿商品，之後收到帳單再付給銀行' }
  ];

  const QUESTIONS = [
    { text: '哪一個是「儲值卡」的正確流程？', answerKey: 'prepaid' },
    { text: '哪一個是「信用卡」的正確流程？', answerKey: 'credit' },
    { text: '哪個是「先儲值再消費」？', answerKey: 'prepaid' },
    { text: '哪個是「先消費後繳款」？', answerKey: 'credit' },
    { text: '要強調「預付」的是哪一個？', answerKey: 'prepaid' },
    { text: '要強調「延後付款」的是哪一個？', answerKey: 'credit' },
  ];

  // ====== Game state ======
  let running = false;
  let ducks = [];
  let score = 0;
  let streak = 0;

  let round = 1;
  const ROUND_MAX = 5;
  roundMaxEl.textContent = String(ROUND_MAX);

  let currentQ = null;
  let remaining = 0;
  const DUCKS_PER_ROUND = 8;

  // ====== Duck object ======
  function makeDuck(choiceKey) {
    const w = 190, h = 70;
    const margin = 20;

    const x = Math.random() * (gameEl.clientWidth - w - margin*2) + margin;
    const y = Math.random() * (gameEl.clientHeight * 0.55) + 60;

    const speed = (Math.random() * 1.3 + 0.9) * (Math.random() < 0.5 ? -1 : 1);
    const bob = Math.random() * 0.8 + 0.4;
    const color = choiceKey === 'prepaid' ? 'rgba(0, 230, 180, 0.92)' : 'rgba(80, 130, 255, 0.92)';

    return {
      choiceKey,
      x, y, w, h,
      vx: speed,
      t: Math.random() * 10,
      bob,
      color,
      alive: true,
    };
  }

  function pickQuestion() {
    currentQ = QUESTIONS[Math.floor(Math.random() * QUESTIONS.length)];
    qText.textContent = currentQ.text;
  }

  function setMsg(text) { msgEl.textContent = text; }
  function updateHUD() {
    scoreEl.textContent = String(score);
    streakEl.textContent = String(streak);
    roundEl.textContent = String(round);
  }

  function spawnRound() {
    pickQuestion();
    ducks = [];
    remaining = DUCKS_PER_ROUND;

    // 保證至少 1 隻正確 + 1 隻錯誤，其他亂數
    const mustCorrect = makeDuck(currentQ.answerKey);
    const mustWrong = makeDuck(currentQ.answerKey === 'prepaid' ? 'credit' : 'prepaid');
    ducks.push(mustCorrect, mustWrong);

    while (ducks.length < DUCKS_PER_ROUND) {
      const k = Math.random() < 0.5 ? 'prepaid' : 'credit';
      ducks.push(makeDuck(k));
    }

    setMsg('開始！打到「符合題目」的鴨子。');
  }

  function endRound() {
    if (round >= ROUND_MAX) {
      running = false;
      setMsg(`結束！總分 ${score}。按「重來」再玩一次。`);
      startBtn.textContent = '再玩一局';
      return;
    }
    round += 1;
    spawnRound();
    updateHUD();
  }

  function resetAll() {
    running = false;
    ducks = [];
    score = 0;
    streak = 0;
    round = 1;
    pickQuestion();
    updateHUD();
    setMsg('按「開始」出第一波鴨子。');
    startBtn.textContent = '開始';
  }

  // ====== Hit detection ======
  function toLocalXY(ev) {
    const rect = canvas.getBoundingClientRect();
    const clientX = (ev.touches && ev.touches[0]) ? ev.touches[0].clientX : ev.clientX;
    const clientY = (ev.touches && ev.touches[0]) ? ev.touches[0].clientY : ev.clientY;
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  }

  function shootAt(x, y) {
    if (!running) return;

    // 從上層開始檢查（後畫的在上面）
    for (let i = ducks.length - 1; i >= 0; i--) {
      const d = ducks[i];
      if (!d.alive) continue;

      if (x >= d.x && x <= d.x + d.w && y >= d.y && y <= d.y + d.h) {
        // hit
        d.alive = false;
        remaining -= 1;

        const correct = (d.choiceKey === currentQ.answerKey);
        if (correct) {
          score += 10;
          streak += 1;
          setMsg(`✅ 打中！正確是：${labelOf(currentQ.answerKey)}（${flowOf(currentQ.answerKey)}）`);
        } else {
          score = Math.max(0, score - 5);
          streak = 0;
          setMsg(`❌ 打錯！正確是：${labelOf(currentQ.answerKey)}（${flowOf(currentQ.answerKey)}）`);
        }

        updateHUD();

        if (remaining <= 0 || ducks.every(dd => !dd.alive)) {
          setTimeout(endRound, 700);
        }
        return;
      }
    }

    // miss
    streak = 0;
    updateHUD();
    setMsg('沒打到鴨子…再試一次。');
  }

  function labelOf(key){
    const c = CHOICES.find(x => x.key === key);
    return c ? c.label : key;
  }
  function flowOf(key){
    const c = CHOICES.find(x => x.key === key);
    return c ? c.flow : '';
  }

  // ====== Render ======
  function drawDuck(d) {
    // body
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 12;
    ctx.fillStyle = d.color;
    roundRect(d.x, d.y, d.w, d.h, 14);
    ctx.fill();
    ctx.shadowBlur = 0;

    // label
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.font = '700 14px system-ui, -apple-system, "Noto Sans TC", sans-serif';
    const t1 = (d.choiceKey === 'prepaid') ? '儲值卡' : '信用卡';
    ctx.fillText(t1, d.x + 12, d.y + 26);

    ctx.fillStyle = 'rgba(255,255,255,0.88)';
    ctx.font = '600 13px system-ui, -apple-system, "Noto Sans TC", sans-serif';
    const t2 = (d.choiceKey === 'prepaid') ? '先儲值 → 再消費' : '先消費 → 後繳款';
    ctx.fillText(t2, d.x + 12, d.y + 48);

    // tiny "beak"
    ctx.fillStyle = 'rgba(255,190,80,0.95)';
    ctx.beginPath();
    ctx.moveTo(d.x + d.w - 6, d.y + d.h/2 - 6);
    ctx.lineTo(d.x + d.w + 10, d.y + d.h/2);
    ctx.lineTo(d.x + d.w - 6, d.y + d.h/2 + 6);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function roundRect(x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function draw() {
    const W = gameEl.clientWidth;
    const H = gameEl.clientHeight;

    // clear
    ctx.clearRect(0,0,W,H);

    // ground
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fillRect(0, H*0.78, W, H*0.22);

    // center reticle
    ctx.strokeStyle = 'rgba(255,255,255,0.28)';
    ctx.beginPath();
    ctx.arc(W/2, H/2, 10, 0, Math.PI*2);
    ctx.stroke();

    // ducks
    ducks.forEach(d => {
      if (!d.alive) return;
      drawDuck(d);
    });

    requestAnimationFrame(draw);
  }

  function tick() {
    if (!running) { requestAnimationFrame(tick); return; }

    const W = gameEl.clientWidth;

    ducks.forEach(d => {
      if (!d.alive) return;
      d.t += 0.04;
      d.x += d.vx;
      d.y += Math.sin(d.t) * d.bob;

      // bounce
      if (d.x < 10) { d.x = 10; d.vx *= -1; }
      if (d.x + d.w > W - 10) { d.x = W - d.w - 10; d.vx *= -1; }
    });

    requestAnimationFrame(tick);
  }

  // ====== Events ======
  canvas.addEventListener('click', (ev) => {
    const p = toLocalXY(ev);
    shootAt(p.x, p.y);
  });
  canvas.addEventListener('touchstart', (ev) => {
    const p = toLocalXY(ev);
    shootAt(p.x, p.y);
  }, { passive: true });

  startBtn.addEventListener('click', () => {
    if (!running) {
      running = true;
      spawnRound();
      updateHUD();
      startBtn.textContent = '進行中…';
    } else {
      // no-op
    }
  });

  restartBtn.addEventListener('click', () => resetAll());

  // ====== Boot ======
  resize();
  pickQuestion();
  updateHUD();
  draw();
  tick();
})();
</script>
</body>
</html>
